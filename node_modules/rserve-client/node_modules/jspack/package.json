{
  "author": {
    "name": "https://github.com/pgriess"
  },
  "name": "jspack",
  "description": "JavaScript library to pack primitives to octet arrays, including int64 support, packaged for NodeJS.",
  "version": "0.0.4",
  "homepage": "https://github.com/birchroad/node-jspack",
  "repository": {
    "type": "git",
    "url": "git://github.com/birchroad/node-jspack.git"
  },
  "main": "./jspack.js",
  "maintainers": [
    {
      "name": "Peter Magnusson",
      "email": "peter@birchroad.net",
      "url": "http://github.com/birchroad/node-jspack"
    },
    {
      "name": "Andreas Antener",
      "url": "https://github.com/AndreasAntener/node-jspack"
    }
  ],
  "devDependencies": {
    "should": "",
    "mocha": "",
    "sinon": "",
    "long": ""
  },
  "scripts": {
    "pretest": "npm install",
    "test": "mocha test"
  },
  "readme": "jspack - library to pack primitives to octet arrays\n====================================================\n\n[![Build status](https://travis-ci.org/birchroad/node-jspack.svg?branch=master)](https://travis-ci.org/birchroad/node-jspack)\n\n## Disclaimer\nThe jspack module and documentation are essentially ports of the\nPython struct module and documentation, with such changes as were necessary. The port was originaly made by Fair Oaks Labs, Inc. and published at http://code.google.com/p/jspack/\nIf any Python people are miffed that their documentation got ripped off, let me know,\nand I'll gladly revise them.\n\nThis module performs conversions between JavaScript values and C structs\nrepresented as octet arrays (i.e. JavaScript arrays of integral numbers\nbetween 0 and 255, inclusive).  It uses format strings (explained below) as\ncompact descriptions of the layout of the C structs and the intended conversion\nto/from JavaScript values.  This can be used to handle binary data stored in\nfiles, or received from network connections or other sources.\n\n## Install\n    npm install jspack\n\n## Reference\n\nThe module defines the following functions:\n\n### Unpack(fmt, a, p)\nReturn an array containing values unpacked from the octet array a,\nbeginning at position p, according to the supplied format string.  If there\nare more octets in a than required by the format string, the excess is\nignored.  If there are fewer octets than required, Unpack() will return\nundefined.  If no value is supplied for the p argument, zero is assumed.\n\n### PackTo(fmt, a, p, values)\nPack and store the values array into the supplied octet array a, beginning\nat position p.  If there are more values supplied than are specified in the\nformat string, the excess is ignored.  If there are fewer values supplied,\nPackTo() will return false.  If there is insufficient space in a to store\nthe packed values, PackTo() will return false.  On success, PackTo() returns\nthe a argument. If any value is of an inappropriate type, the results are\nundefined.\n\n### Pack(fmt, values)\nReturn an octet array containing the packed values array.  If there are\nmore values supplied than are specified in the format string, the excess is\nignored.  If there are fewer values supplied, Pack() will return false.  If\nany value is of an inappropriate type, the results are undefined.\n\n### CalcLength(fmt)\nReturn the number of octets required to store the given format string.\n\n\n## Formats\nFormat characters have the following meanings; the conversion between C and\nJavaScript values should be obvious given their types:\n\n    Format | C Type         | JavaScript Type   | Size (octets) | Notes\n    -------------------------------------------------------------------\n       A   | char[]         | Array             |     Length     |  (1)\n       x   | pad byte       | N/A               |        1       |\n       c   | char           | string (length 1) |        1       |  (2)\n       b   | signed char    | number            |        1       |  (3)\n       B   | unsigned char  | number            |        1       |  (3)\n       h   | signed short   | number            |        2       |  (3)\n       H   | unsigned short | number            |        2       |  (3)\n       i   | signed int     | number            |        4       |  (3)\n       I   | unsigned int   | number            |        4       |  (3)\n       l   | signed long    | number            |        4       |  (3)\n       L   | unsigned long  | number            |        4       |  (3)\n       q   | signed long    | number            |        8       |  (6)\n       Q   | unsigned long  | number            |        8       |  (6)\n       s   | char[]         | string            |     Length     |  (2)\n       f   | float          | number            |        4       |  (4)\n       d   | double         | number            |        8       |  (5)\n\n*Notes:*\n\n  **(1)** The \"A\" code simply returns a slice of the source octet array.  This is\n  primarily useful when a data structure contains bytes which are subject to\n  multiple intepretations (e.g. unions), and the data structure is being\n  decoded in multiple passes.\n\n  **(2)** The \"c\" and \"s\" codes handle strings with codepoints between 0 and 255,\n  inclusive.  The data are not bounds-checked, so strings containing  characters\n  with codepoints outside this range will encode to \"octet\" arrays that contain\n  values outside the range of an octet.  Furthermore, since these codes decode\n  octet arrays by assuming the octets represent UNICODE codepoints, they may\n  not \"correctly\" decode bytes in the range 128-255, since that range is subject\n  to multiple interpretations.  Caveat coder!\n\n  **(3)** The 8 \"integer\" codes clip their encoded values to the minima and maxmima\n  of their respective types:  If you invoke Struct.Pack('b', [-129]), for\n  instance, the result will be [128], which is the octet encoding of -128,\n  which is the minima of a signed char.  Similarly, Struct.Pack('h', [-32769])\n  returns [128, 0].  Fractions are truncated.\n\n  **(4)** Since JavaScript doesn't natively support 32-bit floats, whenever a float\n  is stored, the source JavaScript number must be rounded.  This module applies\n  correct rounding during this process.  Numbers with magnitude greater than or\n  equal to 2^128-2^103 round to either positive or negative Infinity. The\n  rounding algorithm assumes that JavsScript is using exactly 64 bits of\n  floating point precision; 128-bit floating point will result in subtle errors.\n\n  **(5)** This module assumes that JavaScript is using 64 bits of floating point\n  precision, so the \"d\" code performs no rounding.  128-bit floating point will\n  cause the \"d\" code to simply truncate significands to 52 bits.\n\n  **(6)** Since 64bit longs cannot be represented by numbers JavaScript, this version of\n  jspack will process longs as arrays in the form: ```[lowBits, hightBits]```. The\n  decoded long array contains a third element, the unsigned flag, which is ```false``` for signed\n  and ```true``` for unsigned values.\n  This representation is similar to what [Long.js](https://github.com/dcodeIO/Long.js), and\n  therefore the [Google Closure Libaray](https://github.com/google/closure-library), uses.\n  See [test/int64.js](test/int64.js) for examples how to work with Long.js.\n\nA format character may be preceded by an integral repeat count.  For example,\nthe format string \"4h\" means exactly the same thing as \"hhhh\".\n\nWhitespace characters between formats are ignored; a count and its format must\nnot be separated by whitespace, however.\n\nFor the \"A\" format character, the count is interpreted as the size of the\narray, not a repeat count as for the other format characters; for example, \"10A\"\nmeans a single 10-octet array.  When packing, the Array is truncated or padded\nwith 0 bytes as appropriate to make it conform to the specified length.  When\nunpacking, the resulting Array always has exactly the specified number of bytes.\nAs a special case, \"0A\" means a single, empty Array.\n\nFor the \"s\" format character, the count is interpreted as the size of the\nstring, not a repeat count as for the other format characters; for example,\n\"10s\" means a single 10-byte string, while \"10c\" means 10 characters.  When\npacking, the string is truncated or padded with 0 bytes as appropriate to make\nit conform to the specified length.  When unpacking, the resulting string always\nhas exactly the specified number of bytes.  As a special case, \"0s\" means a\nsingle, empty string (while \"0c\" means 0 characters).\n\n\nBy default, C numbers are represented in network (or big-endian) byte order.\nAlternatively, the first character of the format string can be used to indicate\nbyte order of the packed data, according to the following table:\n\n    Character | Byte Order\n    ----------------------------------\n        <     | little-endian\n        >     | big-endian\n        !     | network (= big-endian)\n\nIf the first character is not one of these, \"!\" is assumed.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/birchroad/node-jspack/issues"
  },
  "_id": "jspack@0.0.4",
  "_shasum": "32dd35c7fdcb3e3456c18fbb7ef9ed0bc6238177",
  "_from": "jspack@0.0.x",
  "_resolved": "https://registry.npmjs.org/jspack/-/jspack-0.0.4.tgz"
}
